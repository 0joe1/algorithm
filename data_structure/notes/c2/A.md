# 抽象数据类型

## 接口与实现

![image-20240602222508498](/home/username/.config/Typora/typora-user-images/image-20240602222508498.png)



### 向量ADT

向量各元素与 [0,n) 内的秩(rank)一一对应

可以且只能用提供的接口进行操作。

#### 接口

![image-20240603222909602](assets/image-20240603222909602.png)

#### 接口操作示例

![image-20240603224218679](assets/image-20240603224218679.png)



### 扩容

#### 递增式扩容

![image-20240623120135144](assets/image-20240623120135144.png)

#### 加倍式扩容

![image-20240623120943526](assets/image-20240623120943526.png)



### 分摊复杂度

![image-20240604172911066](assets/image-20240604172911066.png)



### 二分查找

#### 语义

添加两个哨兵lo和hi分别作为负无穷和正无穷

![image-20240610174113838](assets/image-20240610174113838.png)

#### 原理

![image-20240610174833438](assets/image-20240610174833438.png)



#### 实现

![image-20240610174647112](assets/image-20240610174647112.png)

线性递归：$T(n)=T(n/2)+O(1)=O(logn)$ 大大优于顺序查找

递归跟踪：轴点总取中点，递归深度$O(logn)$；各递归实例均耗时$O(1)$



![image-20240613164606614](assets/image-20240613164606614.png)



### Fib 查找

![image-20240613170608654](assets/image-20240613170608654.png)

#### 实现

![image-20240613170940318](assets/image-20240613170940318.png)

#### 最优性证明

![image-20240614091632527](assets/image-20240614091632527.png)



### 二分查找（B）

![image-20240614093334737](assets/image-20240614093334737.png)

#### 语义约定

![image-20240614093516289](assets/image-20240614093516289.png)

#### 实现

不变性：e在[lo,hi) 的范围内

初始时：显而易见

数学归纳：

1. e < A[mi] ， hi=mi 。e在[lo,hi) 的范围内
2. A[mi] <= e，lo=mi。e在[lo,hi) 的范围内

![image-20240614093835941](assets/image-20240614093835941.png)





### 版本C

![image-20240616162346212](assets/image-20240616162346212.png)

#### 正确性：

![image-20240616164253051](assets/image-20240616164253051.png)





## 插值查找

#### 原理

![image-20240618225758260](assets/image-20240618225758260.png)



#### 实例

![image-20240618230417429](assets/image-20240618230417429.png)



#### 性能分析

![image-20240621213054673](assets/image-20240621213054673.png)

##### 形象解释

二分查找在n个数中查找，时间复杂度是 $O(logn)$ 。

这里相当于对 n 的二进制位宽度进行二分查找，时间复杂度是$O(loglogn)$

![image-20240621214426572](assets/image-20240621214426572.png)





### 归并排序

#### 实现

![image-20240622215735108](assets/image-20240622215735108.png)

#### 正确性

不会覆盖

(b) 中显然有 k>=i，因此C中k之前的元素一定无用了，可以被覆盖掉。唯一从C修改当前未处理的情况就是k==i，将同一个元素搬到同一个位置等于没有修改。因此不会覆盖。

![image-20240622220651086](assets/image-20240622220651086.png)

#### 复杂度

![image-20240622221807947](assets/image-20240622221807947.png)
