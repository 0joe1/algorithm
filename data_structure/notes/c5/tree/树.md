### 树

#### 动机

![image-20241201161334203](/home/username/.config/Typora/typora-user-images/image-20241201161334203.png)



#### 有根树

![image-20241201161943200](assets/image-20241201161943200.png)

如果T1,T2...Td为有根树，那么再引入一个新的节点r。【该节点 与 其他之前已有的节点，以及该节点与其他节点的连接形成的边 与 其他之前原有的边】，这个集合构成了一个新的树。



#### 有序树

![image-20241201162732722](assets/image-20241201162732722.png)

边数=所有点的出度之和=顶点总数-1

=》如果将一棵树的规模看作是(n+e)，那么从渐进的意义上看与点数同阶。



#### 路径与环路

![image-20241201163034359](assets/image-20241201163034359.png)



#### 连通+无环

![image-20250402110007163](assets/image-20250402110007163.png)

![image-20250402110255765](assets/image-20250402110255765.png)

每一个点拥有了一个指标：从根节点到该节点的路径长度。

通过这样的指标，可以将所有的节点划分为不同的几类。如此，具有相同指标的也称为等价类。



#### 深度+层次

![image-20250402111136439](assets/image-20250402111136439.png)

某一节点的在某一深度的祖先唯一，但后代不一定唯一。

![image-20250402111958482](assets/image-20250402111958482.png)



### 树的表示

#### 表示法与接口

![image-20250403213712879](assets/image-20250403213712879.png)

#### 父亲

![image-20250403214257041](assets/image-20250403214257041.png)

![image-20250403214440499](assets/image-20250403214440499.png)

#### 孩子

![image-20250403214815093](assets/image-20250403214815093.png)

这个表示法，查找孩子与兄弟的计算量正比于节点的孩子数量，不错。

但向上查找的优势消失殆尽了，需要遍历整个序列来找。



#### 父亲+孩子

![image-20250403220025924](assets/image-20250403220025924.png)

这种方法结合了之前两种方法的优势，但仍有美中不足。

缺点在于每个节点所指向的数据集的规模不平衡。本来总数据规模=各节点出度之和=总边数=n-1，是O(n)的。平均到每个节点都是O(1)的数据规模，但是这里有可能在一个节点集中太多数据从而减慢查找效率。

#### 长子+兄弟

![image-20250404213157450](assets/image-20250404213157450.png)



### 有根有序树=二叉树

#### 二叉树

![image-20250404213451750](assets/image-20250404213451750.png)

![image-20250404213841988](assets/image-20250404213841988.png)

![image-20250404214138601](assets/image-20250404214138601.png)



#### 真二叉树

![image-20250404214505564](assets/image-20250404214505564.png)

每个节点的出度都是偶数（0或2）。为此，可以假想为每个节点添加足够的孩子节点。（并不需要真实添加，只需假想）

从渐进的意义上讲，规模与原先相当。

#### 描述多叉树

![image-20250405105735596](assets/image-20250405105735596.png)

#### 二叉树实现

![image-20250405111211565](assets/image-20250405111211565.png)

![image-20250405110822239](assets/image-20250405110822239.png)

![image-20250406213746136](assets/image-20250406213746136.png)

二叉树是一个庞大的家族，每个成员对高度的定义及更新的方法不尽相同，因此将它定义为虚方法，可以便于各种派生类对这个方法进行适当的重写。

#### 高度更新

![image-20250406214532371](assets/image-20250406214532371.png)

#### 节点插入

![image-20250406214748157](assets/image-20250406214748157.png)



### 先序遍历

![image-20250407105607510](assets/image-20250407105607510.png)

二叉树是串性结构，通过某种原则将二叉树转化为某种线性次序，方便研究。

接下来介绍的图结构也有类似的思想，将还不熟的非线性结构转化为较为熟悉的串性结构来处理。

#### 遍历规则

![image-20250407110940143](assets/image-20250407110940143.png)

#### 递归实现

![image-20250408170916560](assets/image-20250408170916560.png)

#### 迭代实现（1）

![image-20250408171158242](assets/image-20250408171158242.png)



#### 迭代实现（2）

![image-20250408170654433](assets/image-20250408170654433.png)

将起始于树根的，从沿着左侧分支不断下行的链，称作是当前这颗子树的左侧链。



![image-20250408171511907](assets/image-20250408171511907.png)

统一的将二叉树画成这样一个形式：将左侧链的每一个节点突出地绘制出来，每一个节点都有一个右子树（即使可能不存在），其他部分都被归入到这些右子树中。

从宏观上看，先自顶向下遍历左侧链上的节点，然后自底向上依次偏历各个节点上的每一个右子树。



![image-20250408172022557](assets/image-20250408172022557.png)

![image-20250408172246183](assets/image-20250408172246183.png)

![image-20250409094153612](assets/image-20250409094153612.png)



### 中序遍历

#### 递归

![image-20250409095316079](assets/image-20250409095316079.png)

#### 观察

![image-20250410164045367](assets/image-20250410164045367.png)

节点会将控制权“谦让”给它的左侧分支。

可以将中序遍历分解为在不同尺度下的，一系列对左侧分支的逐步处理。

#### 思路

![image-20250410165709611](assets/image-20250410165709611.png)

将二叉树分解为左侧链和左侧链各节点右孩子右子树。

首先得到访问的是左侧链的末端，然后是该节点的右子树。这之后把它的控制权返回上层节点，此时之前的那些左侧节点可以等效看作未曾存在过。



![image-20250410165029928](assets/image-20250410165029928.png)

各节点实际被访问的顺序大致自下而上，与“谦让”的方向相反，应该我们应该考虑采用某种后进先出的数据结构。

#### 实现

![image-20250410170122927](assets/image-20250410170122927.png)

#### 实例

![image-20250410170652290](assets/image-20250410170652290.png)

#### 分摊分析

![image-20250411204740688](assets/image-20250411204740688.png)

看似是O($n^2$)，实际所有这些左侧链的长度合在一起也无非是O(n)。

从常系数的意义而言，要远胜于递归的版本。



### 后序遍历

![image-20250411210035089](assets/image-20250411210035089.png)

![image-20250411210715494](assets/image-20250411210715494.png)

![image-20250412212947028](assets/image-20250412212947028.png)

#### 表达式树

![image-20250412213908183](assets/image-20250412213908183.png)

![image-20250412214014934](assets/image-20250412214014934.png)



### 层次遍历

#### 实现

![image-20250413164450687](assets/image-20250413164450687.png)

#### 实例

![image-20250413165432785](assets/image-20250413165432785.png)



### 重构

![image-20250413165647587](assets/image-20250413165647587.png)

由二叉树可以明确地导出这三个遍历序列。那么反过来，这三个序列能否忠实地还原出原来的树？什么情况下可以，什么情况下不行，如果可以又该使用什么方法。



#### 【先序|后序】+中序

![image-20250413170856971](assets/image-20250413170856971.png)

给定先序或后序可以得到树根节点是谁，然后可以在中序序列中对其进行定位。它可以在中序遍历序列中起到一个切分的作用，使我们得以分别确认左子树和右子树所对应的子序列。这样，我们将原来的树的重构问题化简为两个子树的重构问题。

根据归纳假设，两颗子树都可按上面的方法重构。

只凭先序和后序无法保证子树的正确切分。因为当左子树或右子树不存在的时候，还原时无法确定到底缺失的是左子树还是右子树。

#### (先序+后序)x真

![image-20250414102522549](assets/image-20250414102522549.png)

真二叉树可以



### Huffman树

#### 无前缀冲突编码

![image-20250414103054300](assets/image-20250414103054300.png)

#### 编码成本

![image-20250414104627778](assets/image-20250414104627778.png)

如果有高度差>=2的叶子节点，交换不亏。因为叶子的父亲与上面的叶子交换后，平均编码长度与父亲只有一片叶子相同，但此时父亲还能再有一个儿子，就赚了。

#### 带权编码成本

![image-20250415211647045](assets/image-20250415211647045.png)

#### 编码算法

![image-20250415212305330](assets/image-20250415212305330.png)

#### 构造编码树
